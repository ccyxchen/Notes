# 展锐稳定性机制分析
## soc dump
soc dump在minidump中对应的文件是etb_data

```c
//通过写寄存器关闭ETB
void sprd_etb_hw_dis(void)
{
	u32 ffcr;
	CS_UNLOCK(ETB_BASE);

	ffcr = readl(ETB_BASE + ETB_FFCR_LK);
	/* stop formatter when a stop has completed */
	ffcr |= ETB_FFCR_STOP_FI_LK;
	writel(ffcr, ETB_BASE + ETB_FFCR_LK);
	/* manually generate a flush of the system */
	ffcr |= ETB_FFCR_FON_MAN_LK;
	writel(ffcr, ETB_BASE + ETB_FFCR_LK);

	writel(0x0, ETB_BASE + ETB_CTL_REG_LK);
	CS_LOCK(ETB_BASE);
}

void sprd_etb_dump (void)
{
	int i;
	unsigned char *buf_ptr = NULL;
	u32 read_data;
	u32 read_ptr, write_ptr;
	u32 frame_off, frame_endoff;

	buf_ptr = (unsigned char *)etb_dump_mem;

	CS_UNLOCK(ETB_BASE);

	read_ptr = readl(ETB_BASE + ETB_RAM_READ_POINTER_LK);
	write_ptr = readl(ETB_BASE + ETB_RAM_WRITE_POINTER_LK);
	etb_buf_size = readl(ETB_BASE + ETB_RAM_DEPTH_LK_REG);

	frame_off = write_ptr % ETB_FRAME_SIZE_WORDS;
	frame_endoff = ETB_FRAME_SIZE_WORDS - frame_off;
	if (frame_off)
		write_ptr += frame_endoff;

	if ((readl(ETB_BASE + ETB_STATUS_LK_REG) & ETB_STATUS_RAM_FULL_LK) == 0)
		writel(0x0, ETB_BASE + ETB_RAM_READ_POINTER_LK);
	else
		writel(write_ptr, ETB_BASE + ETB_RAM_READ_POINTER_LK);

	for (i = 0; i < etb_buf_size; i++) {
		read_data = readl(ETB_BASE + ETB_RAM_READ_DATA_LK_REG);
		*buf_ptr++ = read_data >> 0;
		*buf_ptr++ = read_data >> 8;
		*buf_ptr++ = read_data >> 16;
		*buf_ptr++ = read_data >> 24;
	}

	if (frame_off) {
		buf_ptr -= (frame_endoff * 4);
		for (i = 0; i < frame_endoff; i++) {
			*buf_ptr++ = 0x0;
			*buf_ptr++ = 0x0;
			*buf_ptr++ = 0x0;
			*buf_ptr++ = 0x0;
		}
	}

	//writel(read_ptr, ETB_BASE + ETB_RAM_READ_POINTER_LK);
	/* Read_pointer has been set as 0x7cb0 in sprd_log_point.c
         * Read_pointer should be set as 0x0 to dump etb.bin for soc_dump function
        */
	writel(0x0, ETB_BASE + ETB_RAM_READ_POINTER_LK);
	CS_LOCK(ETB_BASE);
}

#ifdef CONFIG_ETB_DUMP
void save_soc_dump_to_minidump(void)
{
	struct section_info_extend section_info_extend;
	int ret;

	dump_logd ("Start to dump ETB trace data to minidump\n");
	sprd_etb_hw_dis();
	sprd_etb_dump();
	section_info_extend.paddr = &etb_dump_mem[0];
	section_info_extend.size = etb_buf_size * 4;
	memset(section_info_extend.section_name, 0, SECTION_NAME_LEN_MAX);
	memcpy(section_info_extend.section_name, ETB_DATA, strlen(ETB_DATA));
	dump_logd("section_name: %s \n", section_info_extend.section_name);
	ret = sysdump_save_extend_info(&section_info_extend);
	if (ret)
		dump_loge("save soc_dump to bootloader section failed ! \n");
}
#endif
```
## minidump 原理
minidump 是基于展锐的sysdump 驱动，该驱动会使用一块预留的内存区域保存sysdump和minidump的结构体。
其中minidump的关键结构体为：
```c
/* the struct to save minidump all infomation  */
struct minidump_info{
	char kernel_magic[6];  				  /* make sure minidump data valid */
	struct regs_info regs_info;			  /* | struct pt_regs | 			*/
	struct regs_memory_info regs_memory_info;	  /* | memory amount regs |  , need paddr and size, if paddr invalid set it as 0  */
	struct section_info_total section_info_total;	  /* | sections | , text,rodata,page_table ....,may be logbuf in here */
	int minidump_elfhdr_size;			  /* minidump elfhdr data size: update in uboot  */
	int minidump_elfhdr_size_comp;			  /* minidump elfhdr data size,after compressed  */
	struct minidump_data_desc  desc;		  /* minidump contents description */
	int minidump_data_size;				  /* minidump data total size: regs_all_size + reg_memory_all_size + section_all_size  */
	int compressed;					  /* indicate if minidump data compressed */
	struct exception_info_item exception_info;	  /* exception info */
};

struct section_info_total{
	struct section_info section_info[SECTION_NUM_MAX];
	int total_size;
	int total_num;
};

struct section_info{
	char section_name[SECTION_NAME_MAX];
	/*Get teh value in kernel use to record elfhdr info in uboot*/
	unsigned long section_start_vaddr;
	unsigned long section_end_vaddr;
	/*Get the value in kernel by __pa  use to get memory contents in uboot */
	unsigned long section_start_paddr;
	unsigned long section_end_paddr;
	int section_size;
	int section_size_comp; 			/* size after compressed  */
};

//需要保存的子系统log存放在section_info结构体中，每个section_info对应一份log，log的内存是子系统自己申请
的，其物理地址保存在section_start_paddr和section_end_paddr

//新建minidump的section：
/**
 * save extend debug information of modules in minidump, such as: cm4, iram...
 *
 * @name:	the name of the modules, and the string will be a part
 *		of the file name.
 *		note: special characters can't be included in the file name,
 *		such as:'?','*','/','\','<','>',':','"','|'.
 *
 * @paddr_start:the start paddr in memory of the modules debug information
 * @paddr_end:	the end paddr in memory of the modules debug information
 *
 * Return: 0 means success, -1 means fail.
 */
int minidump_save_extend_information(const char *name, unsigned long paddr_start,
								unsigned long paddr_end)
```
开机LK阶段会检测硬件寄存器，判断发生dump后，保存minidump到sysdumpdb 分区
重启到系统，使用minidumpd 程序将新出现的sysdumpdb 内容解析到/data/minidump 目录下

minidumpd 程序：system/vendor/sprd/modules/minidump/
该程序读取sysdumpdb 内保存的结构体信息，提取出minidump 文件

本地编译出mindump的x86 版本，可以提取sysdumpdb 导出分区文件

## sysdump使能控制
```C
//读取sysdumpdb,设置sysdump和minidump的使能
int init_dump_status(struct dumpdb_header *dump_status_header, int *minidump_status,
					int *fulldump_status, int rst_mode)
{
	if((IS_ORIG_STATUS(dump_status_header->dump_flag)) || (rst_mode == CMD_RECOVERY_MODE)) {
		dump_status_header->dump_flag &= SYSDUMP_STATUS_MASK;
		dump_logd("dump status is orig:  (0x%x)\n", dump_status_header->dump_flag);
		dump_status_header->dump_flag |= AP_FULL_DUMP_ENABLE;
		dump_logd("Debug mode , set ap full dump enable default . (0x%x) \n", dump_status_header->dump_flag);
		dump_status_header->dump_flag |= AP_MINI_DUMP_ENABLE;
		dump_logd("Always set ap mini dump enable default .  (0x%x) \n", dump_status_header->dump_flag);
                /* record the status of dumpdb_header struct */
		record_dumpdb_header_status(dump_status_header);
                /*      updadte dump flag data */
		if (common_raw_write(SYSDUMPDB_PARTITION_NAME, (uint64_t)(sizeof(struct dumpdb_header)), (uint64_t)(sizeof(struct dumpdb_header)), (uint64_t)0, (char*)dump_status_header)) {
			dump_loge(" update dump flag  %s error.\n", SYSDUMPDB_PARTITION_NAME);
			return -1;
		}
		*minidump_status = !!(dump_status_header->dump_flag & AP_MINI_DUMP_ENABLE);
		*fulldump_status = !!(dump_status_header->dump_flag & AP_FULL_DUMP_ENABLE);
	} else {
		dump_logd("...Status Changed... , read saved status (0x%x)\n", dump_status_header->dump_flag);
		*minidump_status = !!(dump_status_header->dump_flag & AP_MINI_DUMP_ENABLE);
		*fulldump_status = !!(dump_status_header->dump_flag & AP_FULL_DUMP_ENABLE);
	}
	return 0;
}

//sysdump标志打开，并且reset 类型是panic的几种才进行sysdump
int is_dump_allow(int rst_mode, int status)
{
	int exc_mode;

	exc_mode = is_sysdump_boot_mode(rst_mode);

	if(status && exc_mode)
		return 1;

	return 0;
}

int is_sysdump_boot_mode(int rst_mode)
{
	int i;
	int len;

	len = sizeof(dump_mode) / sizeof(int);

#define TRUE 1
#define FALSE 0

	for(i = 0; i < len; i++) {
		if (rst_mode == dump_mode[i])
			return TRUE;
	}

	return FALSE;
}

/* boot modes that need enter sysdump, the new exception mode should be added here */
int dump_mode[] = {
	CMD_WATCHDOG_REBOOT,
	CMD_AP_WATCHDOG_REBOOT,
	CMD_UNKNOW_REBOOT_MODE,
	CMD_SPECIAL_MODE,
	CMD_PANIC_REBOOT,
	CMD_VMM_PANIC_MODE,
	CMD_TOS_PANIC_MODE,
	CMD_EXT_RSTN_REBOOT_MODE,
	CMD_ABNORMAL_REBOOT_MODE,
	CMD_BOOTLOADER_PANIC_MODE,
	CMD_SML_PANIC_MODE,
};
```

### 使能fulldump的方法
1. 使用fastboot 命令
`fastboot setdump $subcmd`

```c
char *fastboot_subcmd[] = {
	"full-enable",			//CMD_FULL_ENABLE
	"full-disable",			//CMD_FULL_DISABLE
	"mini-enable",			//CMD_MINI_ENABLE
	"mini-disable",			//CMD_MINI_DISABLE
	"status",			//CMD_STATUS
	"autoreboot-enable",		//CMD_AUTOREBOOT_ENABLE
	"autoreboot-disable",		//CMD_AUTOREBOOT_ENABLE
	"dataoutput",			//CMD_DATAOUTPUT
};
```

2. adb 命令
展锐提供工具systemDebuggerd
`/vendor/vendor/sprd/modules/sysdump/`

```c++
#define SPRD_SYSDUMP_CONFIG   "/proc/sprd_sysdump"
#define SPRD_SYSDUMP_PROP   "persist.vendor.sysdump"
#define VERSION_INFO "ro.product.name"
#define DEBUG_FULLDUMP_PROP  "vendor.debug.sysdump.enabled"
#define DEFAULT_PROP_VALUE  "error"
#define SPRD_7S_RESET_PROP "persist.vendor.eng.reset" /*0: soft mode, 1: hard mode*/

int get_ops_type(const char *ops)
{
	int enable = -1;
	if (!strcmp(ops, "true"))
		enable = 1;
	else if (!strcmp(ops, "false"))
		enable = 0;
	else
		ALOGD(" invalid ops  : %s , do nothing  \n", ops);
	return enable;
}

/* only prop status changed means modification ops*/
int is_modify_status(void)
{
	char fulldump_prop_enable[128] = {0};
	int modify_flag = 0;
	int status = -1;

	/*	judge fulldump modification ops */
	if (-1 == property_get(DEBUG_FULLDUMP_PROP, fulldump_prop_enable, DEFAULT_PROP_VALUE)) {
		ALOGD(" get prop error : %s : %s  \n", DEBUG_FULLDUMP_PROP, fulldump_prop_enable);
		return 0;
	} else {
		ALOGD("get prop ok : %s : %s  \n", DEBUG_FULLDUMP_PROP, fulldump_prop_enable);
		status = get_ops_type(fulldump_prop_enable);
		if(-1 == status ) {
			modify_flag = 0;
			ALOGD("modify_flag : %d , need do other ops ...... \n", modify_flag);
		} else {

			if(status)
				set_dump_status(FULL_DUMP_ENABLE);
			else
				set_dump_status(FULL_DUMP_DISENABLE);
			modify_flag = 1;
			ALOGD("modify_flag : %d , do not do other ops, return  ...... \n", modify_flag);
		}
	}
	return modify_flag;
}
```
命令：
```shell
setprop vendor.debug.sysdump.enabled true
systemDebuggerd
```

### LK 导出minidump和sysdump
#### lk 中处理minidump的源码
`vendor/bsp/bootloader/lk/app/sprdboot/minidump.c`
reset mode (int) 和对应的字符串
```C
/* NOTE: the array need be updated on the basis of 'boot_mode_enum_type' */
char *rstmode[CMD_MAX_MODE] = {
	"undefind mode",			//CMD_UNDEFINED_MODE=0,
	"power down",				//CMD_POWER_DOWN_DEVICE,
	"normal",				//CMD_NORMAL_MODE,
	"download",				//CMD_DOWNLOAD_MODE
	"recovery",				//CMD_RECOVERY_MODE,
	"fastboot",				//CMD_FASTBOOT_MODE,
	"alarm",				//CMD_ALARM_MODE,
	"charge",				//CMD_CHARGE_MODE,
	"engtest",				//CMD_ENGTEST_MODE,
	"cm4_watchdog_timeout",			//CMD_WATCHDOG_REBOOT ,
	"ap_watchdog_timeout",			//CMD_AP_WATCHDOG_REBOOT ,
	"framework crash",			//CMD_SPECIAL_MODE,
	"manual_dump",				//CMD_UNKNOW_REBOOT_MODE,
	"kernel_crash",				//CMD_PANIC_REBOOT,
	"vmm_panic",				//CMD_VMM_PANIC_MODE
	"tos_panic",				//CMD_TOS_PANIC_MODE
	"ext rstn reboot",                      //CMD_EXT_RSTN_REBOOT_MODE,
	"calibration",				//CMD_CALIBRATION_MODE,
	"usb mux",                              //CMD_USB_MUX_MODE
	"autodloader",				//CMD_AUTODLOADER_REBOOT,
	"autotest",				//CMD_AUTOTEST_MODE,
	"iq reboot",				//CMD_IQ_REBOOT_MODE,
	"sleep",				//CMD_SLEEP_MODE,
	"sprd disk",				//CMD_SPRDISK_MODE,
	"apk mmi",				//CMD_APKMMI_MODE,
	"upt",					//CMD_UPT_MODE,
	"apkmmi auto",				//CMD_APKMMI_AUTO_MODE,
	"abnormal mode",                        //CMD_ABNORMAL_REBOOT_MODE,
	"silent",                               //CMD_SILENT_MODE,
	"bootloader panic",                     //CMD_BOOTLOADER_PANIC_MODE,
	"sml panic",				//CMD_SML_PANIC_MODE,
};
```
##### lk 中获取rst mode
```C
unsigned reboot_mode_check(void)
{
	static unsigned rst_mode = 0;
	static unsigned check_times = 0;

	if(!check_times) {
		rst_mode = check_reboot_mode();
		check_times++;
	}
	dprintf(INFO,"reboot_mode_check rst_mode=0x%x\n",rst_mode);

	return rst_mode;
}
 #define BIT_REG_RST_FLG ( BIT(13) ) 
  #define HWRST_STATUS_SYSDUMPEN (0x200)
unsigned check_reboot_mode(void)
{
    unsigned hw_rst_mode = ANA_REG_GET(ANA_REG_GLB_POR_SRC_FLAG);
    reg_rst_mode = hw_rst_mode;
	reg_rst_mode &= (0xffff & BIT_REG_RST_FLG);
	dprintf(INFO,"check_reboot_mode:get raw reg_rst_mode is %x\n", reg_rst_mode);
	
    reboot_reg = rst_mode = ANA_REG_GET(ANA_REG_GLB_POR_RST_MONITOR);
	sysdump_flag = rst_mode & HWRST_STATUS_SYSDUMPEN;
	dprintf(INFO,"check_reboot_mode:get raw rst_mode is %x and sysdump_flag is %x\n",rst_mode,sysdump_flag);
	rst_mode &= 0xFF;
	ANA_REG_SET(ANA_REG_GLB_POR_RST_MONITOR, sysdump_flag | 0); //clear flag

	debugf("rst_mode==%x\n",rst_mode);
	hw_wdt_int_raw = hw_watchdog_rst_pending();
	if(hw_wdt_int_raw || reg_rst_mode){
		debugf("hw watchdog rst int pending\n");
		debugf("register reboot method reg_rst_mode is %x\n", reg_rst_mode);
		if(rst_mode == HWRST_STATUS_RECOVERY) {
			bootcause_cmdline="Reboot into reocovery";
			return CMD_RECOVERY_MODE;
		} else if(rst_mode == HWRST_STATUS_FASTBOOT){
			bootcause_cmdline="Reboot into fastboot";
			return CMD_FASTBOOT_MODE;
			...
	｝else{
		dprintf(INFO,"is_7s_reset 0x%x, systemdump 0x%x\n", is_7s_reset(), is_7s_reset_for_systemdump());
		debugf("no hw watchdog and reg rst int pending\n");
		if(is_7s_reset_for_systemdump()) {
			ANA_REG_SET(ANA_REG_GLB_WDG_RST_MONITOR, SW_7SRST_STATUS);
			lr_cause = LR_ABNORMAL;
			bootcause_cmdline="7s reset for systemdump";
			return CMD_UNKNOW_REBOOT_MODE;
		} else if(hw_rst_mode & SW_EXT_RSTN_STATUS) {
			lr_cause = LR_LONG_PRESS;
			bootcause_cmdline="Software extern reset status";
			return CMD_EXT_RSTN_REBOOT_MODE;
		} else if(rst_mode == HWRST_STATUS_NORMAL2) {
			ANA_REG_SET(ANA_REG_GLB_WDG_RST_MONITOR, SW_7SRST_STATUS);
			lr_cause = LR_UNKNOWN;
			bootcause_cmdline="STATUS_NORMAL2 without watchdog pending";
			return CMD_UNKNOW_REBOOT_MODE;
		} else if(is_7s_reset()) {
			lr_cause = LR_ABNORMAL;
			bootcause_cmdline="7s reset";
			return CMD_NORMAL_MODE;
		}
		else
			return 0;
	}
    ...
}
#define WDG_INT_RST_BIT BIT_3
int hw_watchdog_rst_pending(void)
{
	u32 ret = 0;
        /*clk on*/
	ANA_REG_OR(ANA_REG_GLB_ARM_MODULE_EN, BIT_ANA_WDG_EN); //WDG enable
	ANA_REG_OR(ANA_REG_GLB_RTC_CLK_EN,    BIT_RTC_WDG_EN); //WDG Rtc enable

	if (hw_wdt_int_raw_flag == 0x355e)
		hw_wdt_int_raw_flag = wdt_rst_raw_int();
	ret = hw_wdt_int_raw_flag & WDG_INT_RST_BIT;
	dprintf(INFO,"hw watchdog int raw status 0x%x\n", ret);
	wdt_int_clr();

	return ret;
}

static inline u32 wdt_rst_raw_int(void)
{
	return ANA_REG_GET(WDG_INT_RAW);
}
```
rst mode 主要从ANA_REG_GLB_WDG_RST_MONITOR和ANA_REG_GLB_POR_RST_MONITOR寄存器获取，对应的reset mode 
可以从`vendor/bsp/bootloader/lk/platform/sprd_shared/soc/qogirn6l/include/asm/arch/check_reboot.h`查找。
如果发生了pmic watchdog，可以通过WDG_INT_RAW寄存器bit 3读取。
CMD_UNKNOW_REBOOT_MODE 对应的是manual dump.

###### 寄存器说明
ANA_REG_GLB_POR_SRC_FLAG:
![](vx_images/593505268496001.png =796x)
ANA_REG_GLB_POR_RST_MONITOR:
![](vx_images/285384322374828.png =800x)
WDG_INT_RAW:
![](vx_images/183535170005544.png =788x)
![](vx_images/285365199988899.png =779x)
![](vx_images/385072883171549.png =770x)
##### sysdumpdb分区数据存储格式
|                     susdumpdb 空间分布                     |             |
| --------------------------------------------------------- | ----------- |
| struct dumpdb_header                                      |             |
| struct mini_data_header                                   |             |
| struct mini_area_info*5                                   |             |
| struct mini_area_header                                   | area 部分X5 |
| struct mini_section_info\* area section num               | area 部分   |
| mini_area_header->section_num \*mini_section_info->s_size | area 部分   |

流程图：
[lk中的dump流程图.drawio](file:///E:/workspace/Notes/work/2025/lk中的dump流程图.drawio)
#### lk 中处理sysdump的源码
`vendor/bsp/bootloader/lk/app/sprdboot/sysdump.c`
### kernel的sysdump机制

sysdump 驱动在初始化时会注册一些钩子函数，在发生panic, 处理器间中断停止，reboot 等事件时，会执行相应的函数，
这些函数负责保存关键的寄存器和堆栈数据到sysdump的结构体。

代码：
`vendor/bsp/kernel5.15/kernel5.15/drivers/unisoc_platform/sysdump/`
```makefile
sysdump-$(CONFIG_SPRD_SYSDUMP) += \
		unisoc_sysdump.o \
		unisoc_vmcoreinfo.o \
		last_kmsg.o

obj-$(CONFIG_SPRD_SYSDUMP) += sysdump.o

native_hang_monitor-$(CONFIG_SPRD_NATIVE_HANG_MONITOR) += hang_monitor.o sprd_modules_notify.o
obj-$(CONFIG_SPRD_NATIVE_HANG_MONITOR) += native_hang_monitor.o

obj-$(CONFIG_UNISOC_LASTKMSG)	+= unisoc_last_kmsg.o
unisoc_last_kmsg-y := unisoc_dump_info.o
unisoc_last_kmsg-$(CONFIG_UNISOC_DUMP_IO)   += unisoc_dump_io.o
```

## 展锐manual dump的实现
### manual dump使能
```c
//vendor/bsp/bootloader/lk/project/m2518.mk
# 7S reset config
# CONFIG_7S_RST_MODULE_EN	//0:disable module; 1:enable module
# CONFIG_7S_RST_SW_MODE		//0:hw reset,1:arm reset,power keep on	//hard for user version
# CONFIG_7S_RST_SHORT_MODE	//0:long press then release key to trigger;1:press key some time to trigger
# CONFIG_7S_RST_2KEY_MODE	//0:1Key--Normal mode; 1:2KEY
# CONFIG_7S_RST_THRESHOLD	//7S, hold key down for this time to trigger
#

GLOBAL_DEFINES += \
	CONFIG_7S_RST_SW_MODE=1 \
	CONFIG_7S_RST_MODULE_EN=1 \
	CONFIG_7S_RST_SHORT_MODE=1 \
	CONFIG_7S_RST_2KEY_MODE=1 \
	CONFIG_7S_RST_THRESHOLD=8
	
//vendor/bsp/bootloader/lk/platform/sprd_shared/driver/misc/pmic27xx_misc.c
void pmic_misc_init(void)
{
#ifdef CONFIG_ADIE_UMP9620
	if(por_wr_7s_control_enable(CONFIG_7S_RST_MODULE_EN)){
#endif
		pbint_7s_rst_cfg(CONFIG_7S_RST_MODULE_EN,
					CONFIG_7S_RST_SW_MODE,
					CONFIG_7S_RST_SHORT_MODE);
#ifdef CONFIG_ADIE_UMP9620
		por_wr_7s_control_enable(~CONFIG_7S_RST_MODULE_EN);
	}
#endif
}

# 禁用7s_rst 寄存器写保护
#ifdef CONFIG_ADIE_UMP9620
static inline int por_wr_7s_control_enable(uint32_t enable)
{
	if(enable){
		sci_adi_write(ANA_REG_GLB_POR_WR_PROT_VALUE, CONFIG_7S_WR_CONTROL_EN,BIT_POR_WR_PROT_VALUE(~0));
	}
	else{
		sci_adi_write(ANA_REG_GLB_POR_WR_PROT_VALUE, CONFIG_7S_WR_CONTROL_DISABLE,BIT_POR_WR_PROT_VALUE(~0));
	}
	return sci_adi_read(ANA_REG_GLB_POR_WR_PROT_VALUE) & BIT_POR_WR_PROT;
}
#endif

int pbint_7s_rst_cfg(uint32_t en, uint32_t sw_rst, uint32_t short_rst)
{
    pbint_7s_flag = sci_adi_read(ANA_REG_GLB_POR_SRC_FLAG);
	sci_adi_set(ANA_REG_GLB_POR_7S_CTRL, BIT_PBINT_7S_FLAG_CLR);
	udelay(10);
	sci_adi_clr(ANA_REG_GLB_POR_7S_CTRL, BIT_PBINT_7S_FLAG_CLR); //it is necessary,

	/* ignore sw_rst, please refer to config.h */
	if (en) {
		pbint_7s_rst_set_threshold(CONFIG_7S_RST_THRESHOLD);
		pbint_7s_rst_set_sw(!sw_rst);
		pbint_7s_status = ANA_REG_GET(ANA_REG_GLB_WDG_RST_MONITOR);
		dprintf(INFO,"get ANA_REG_GLB_WDG_RST_MONITOR = 0x%x\n", pbint_7s_status);
		ANA_REG_SET(ANA_REG_GLB_WDG_RST_MONITOR, 0);
		/*maintenance requirement 7s is configured soft reset in chipram*/
		if(is_7s_reset()) {
			dprintf(INFO,"is_7s_reset 0x%x\n", is_7s_reset());
			reboot_mode = sci_adi_read(ANA_REG_GLB_POR_RST_MONITOR);
			reboot_mode &= 0xFF;
			if(is_7s_reset_for_systemdump() || reboot_mode == 0xF0) {
				dprintf(INFO,"7s soft reset is changed to hard reset\n");
				pbint_7s_rst_set_sw(sw_rst);
			} else {
				dprintf(INFO,"7s hard reset is changed to soft reset\n");
				pbint_7s_rst_set_sw(!sw_rst);
			}
		} else if (pbint_7s_status == SW_7SRST_STATUS) {
			dprintf(INFO,"7s soft reset is changed to hard reset\n");
			pbint_7s_rst_set_sw(sw_rst);
		}

		pbint_7s_rst_set_swmode(short_rst);

		pbint_7s_rst_set_2keymode(CONFIG_7S_RST_2KEY_MODE);
	}
	return pbint_7s_rst_disable(!en);
}
int is_7s_reset(void)
{
	return pbint_7s_flag & PBINT_7S_SW_FLAG;
}

int is_7s_reset_for_systemdump(void)
{
	int val;
	int mask = PBINT_7S_SW_FLAG | PBINT_7S_HW_FLAG;

	val = pbint_7s_flag & mask;

	return (val == PBINT_7S_SW_FLAG);
}
```
lk中根据ANA_REG_GLB_POR_SRC_FLAG寄存器获取7s_reset标志位。bit 7 是hardware reset,bit 12是sw reset，当判断触发了hard reset或sw reset ，就设置当前的reset mode相反。ANA_REG_GLB_WDG_RST_MONITOR寄存器可以获取wdg 信息，当该值为0x1000说明发生sw reset.

### 寄存器说明
![](vx_images/428176621752741.png =789x)
![](vx_images/446614786050333.png =717x)
![](vx_images/15867623347946.png =705x)
![](vx_images/526286040566569.png =778x)
### manual dump 在kernel的实现
展锐提供驱动，可以设置7s_reset 的mode ,使能，时间，按键方式等
`vendor/bsp/kernel5.15/kernel5.15/drivers/unisoc_platform/sprd_7sreset.c`

## uboot log判断电源异常
当出现uvlo或ovlo时，会打印：
```txt
[00002268] [c0] last shutdown flag ANA_REG_GLB_POR_OFF_FLAG:0x2800
[00002269] [c0] Is power off from smpl

[00003488] [c0] enter mode normal, boot_reason: Sudden momentary power loss, pwroff_reason: uvlo pwroff
```

源码解析：
```c
static void vlx_entry(uchar *dt_addr)
{
#ifdef CONFIG_FASTBOOT_SECURITY_DOWNLOAD
	/* clear reboot-edl flag if necessary */
	if (!fb_check_reboot_edl(NULL)) {
		(void)fb_require_reboot_edl(0);
	}
#endif

	const char *bootmode = g_env_bootmode;
	dprintf(CRITICAL,"enter mode %s, boot_reason: %s, pwroff_reason: %s\n",
		!bootmode ? "normal" : bootmode,
		!bootcause_cmdline ? "Bootcause hasn't been set yet" : bootcause_cmdline,
		!pwroffcause_cmdline ? "pwroffcause hasn't been set yet" : pwroffcause_cmdline);
    ...
}

//从ANA_REG_GLB_POR_OFF_FLAG寄存器获取关机原因
void check_poweroff_mode(void)
{
	unsigned pwroff_reason= 0;
	int ret;

	pwroff_reason = ANA_REG_GET(ANA_REG_GLB_POR_OFF_FLAG);
	dprintf(INFO,"last shutdown flag ANA_REG_GLB_POR_OFF_FLAG:0x%x\n",pwroff_reason);

	sci_adi_set(ANA_REG_GLB_POR_OFF_FLAG, 0xffff);	//clear power off flag

	ret = sci_adi_read(ANA_REG_GLB_SMPL_CTRL1) & BIT_SMPL_PWR_ON_FLAG;
	dprintf(INFO,"%s power off from smpl\n", ret ? "Is" : "Not");

	if(pwroff_reason == HWOFF_STATUS_PD )
		pwroffcause_cmdline = "device power down";
		...
}
```
![](vx_images/383326882965527.png =806x)
![](vx_images/504918878090440.png =767x)


## lastkmsg 实现保存上次开机log
`vendor\bsp\kernel5.15\kernel5.15\drivers\unisoc_platform\sysdump\last_kmsg.c`
```c
static const char *devicename = "/dev/block/by-name/common_rs1_a";
static const char *sdklog_path = "/dev/block/by-name/sd_klog";

static void save_log_to_partition(void *buf)
{
	int ret;
	static struct file *plog_file;

	if (shutdown_save_log_flag == 1)
		return;

	plog_file = filp_open_block(sdklog_path, O_RDWR | O_DSYNC | O_NOATIME | O_EXCL, 0);
	if (IS_ERR(plog_file)) {
		ret = PTR_ERR(plog_file);
		pr_err("failed to open '%s':%d!\n", sdklog_path, ret);
		plog_file = filp_open_block(devicename, O_RDWR | O_DSYNC | O_NOATIME | O_EXCL, 0);
		if (IS_ERR(plog_file)) {
			ret = PTR_ERR(plog_file);
			pr_err("failed to open '%s':%d!\n", devicename, ret);
			return;
		}
	}

	/* handle last kmsg */
	get_last_kmsg(kmsg_buf, KMSG_BUF_SIZE, buf);

	if (kmsg_buf == NULL) {
		pr_err("kmsg_buf is null, return!\n");
		goto end;
	}
	sysdump_set_property(plog_file, UBI_VOL_PROP_DIRECT_WRITE, 1);
	//将kernel log和ylog 保存到log分区
	ret = write_data_to_ubi_partition(plog_file, kmsg_buf, KMSG_BUF_SIZE, LAST_KMSG_OFFSET);
	if (ret != KMSG_BUF_SIZE)
		pr_err("write kmsg to partition error! :%d!\n", ret);

	/* handle last android log */
	if (ylog_buffer == NULL) {
		pr_err("ylog_buffer is null, return!\n");
		goto end;
	}

	ret = write_data_to_ubi_partition(plog_file, ylog_buffer, YLOG_BUF_SIZE,
		LAST_ANDROID_LOG_OFFSET);
	if (ret != YLOG_BUF_SIZE)
		pr_err("write kmsg to partition error! :%d!\n", ret);

end:
	filp_close(plog_file, NULL);

}
```
### ylog 保存的机制
底层会将ylog buffer映射到上层写入：
```c
static int ylog_buffer_map(struct file *filp, struct vm_area_struct *vma)
{
	unsigned long ylog_buffer_paddr;

	if (vma->vm_end - vma->vm_start > YLOG_BUF_SIZE)
		return -EINVAL;

	ylog_buffer_paddr = virt_to_phys(ylog_buffer);
	if (remap_pfn_range(vma,
			vma->vm_start,
			ylog_buffer_paddr >> PAGE_SHIFT, /*	get pfn */
			vma->vm_end - vma->vm_start,
			vma->vm_page_prot))
		return -ENOMEM;

//	pr_info("mmap ylog_buffer ok !\n");
	return 0;
}

static const struct file_operations ylog_buffer_fops = {
	.owner = THIS_MODULE,
	.open = ylog_buffer_open,
	.mmap = ylog_buffer_map,
};

static struct miscdevice misc_dev_ylog = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = DEVICE_NAME_YLOG,
	.fops = &ylog_buffer_fops,
};
static int ylog_buffer_init(void)
{
	int ret;

	ylog_buffer = kzalloc(YLOG_BUF_SIZE, GFP_KERNEL);
	if (ylog_buffer == NULL) {
		return -ENOMEM;
	}
//	pr_info("%s: ylog_buffer vaddr is %p\n", __func__, ylog_buffer);
	snprintf(ylog_buffer, YLOG_BUF_SIZE, "%s", "This is ylog buffer. Now , it is nothing . ");
	/*here, we can add something to head to check if data is ok */
	SetPageReserved(virt_to_page(ylog_buffer));
	ret = misc_register(&misc_dev_ylog);
	return ret;
}
```

上层将log写入ylog buffer
```c++
//system/vendor/sprd/platform/system/logging/logd/YLogBuffer.cpp

unsigned char* YLogBuffer::getDeviceBuff(const char* path, long size) {
    int fd;
    unsigned char *pMap;

    fd = open(path, O_RDWR);
    int er = errno;
    static int fdError = 0;
    if (fd < 0) {
        if (fdError == 0) {
           fdError = 1;
            ALOGD("logd open %s  error:%s", path, strerror(er));
        }
        return NULL;
    }

    pMap = (unsigned char *) mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (pMap == MAP_FAILED) {
        ALOGD("logd  mmap %s  error ", path);
        close(fd);
        return NULL;
    }
    close(fd);
    return pMap;
}

void YLogBuffer::write2RingBuffer(char* logmsg) {
    int len = strlen(logmsg);
    static unsigned char* pMem = NULL;
    static unsigned char* dst = NULL;
    if (NULL == pMem) {
        pMem = getDeviceBuff(LASTANDROID_DEVICE, LASTANDROID_BUF_SIZE);
        if (NULL != pMem) {
            memset(pMem, 0, LASTANDROID_BUF_SIZE);
        }
    }
    static int dataLength = 0;
    int *offset = (int*)pMem;

    if (pMem != NULL) {
        if ((4 + dataLength + len) < LASTANDROID_BUF_SIZE) {
            dst = pMem + 4 + dataLength;
            memcpy(dst, logmsg, len);
            dataLength += len;
        } else {
            memcpy(pMem + 4, logmsg, len);
            dataLength = len;
            dst = pMem + 4 + dataLength;
        }
        *offset = 4 + dataLength;
    }
}

void YLogBuffer::writeAndroidLog2Device(LogBufferElement* element) {
    static unsigned char logData[LOGGER_ENTRY_MAX_LEN];

    struct logger_entry* pLoggerEntry = (struct logger_entry*) logData;
    memset(pLoggerEntry, 0, sizeof (logData));

    pLoggerEntry->hdr_size = sizeof (struct logger_entry);
    pLoggerEntry->lid = element->log_id();
    pLoggerEntry->pid = element->pid();
    pLoggerEntry->tid = element->tid();
    pLoggerEntry->uid = element->uid();
    pLoggerEntry->sec = element->realtime().tv_sec;
    pLoggerEntry->nsec = element->realtime().tv_nsec;
    pLoggerEntry->len = element->msg_len();
    memcpy((char*) pLoggerEntry + pLoggerEntry->hdr_size, element->msg(), element->msg_len());

    AndroidLogEntry androidLogEntry;
    int ret = LogMsg2LogEntry((struct log_msg *) pLoggerEntry, &androidLogEntry);
    if (1 == ret) {
        outputLogEntry(&androidLogEntry);
    }
}

int YLogBuffer::log(log_id_t log_id, log_time realtime, pid_t pid, pid_t tid,
        const char *msg, unsigned short len) {
    LogBufferElement *element = new LogBufferElement(log_id, realtime, mLogUID++, pid, tid, 0, msg, len);

#if defined(DO_LOG_LASTANDROID)
    writeAndroidLog2Device(element);
#endif
    mLogcount++;
    delete element;
    return 0;
}

//调用Android的log服务写入到ylog
//system/system/logging/logd/LogListener.cpp 

void LogListener::HandleData() {
    ...
    logbuf_->Log(logId, header->realtime, cred->uid, cred->pid, header->tid, msg,
                 ((size_t)n <= UINT16_MAX) ? (uint16_t)n : UINT16_MAX);

    /**
     * Unisoc: Intrusive modification
     * write logs to ylog buffer
     * SR: SR.695.002431.007864
     * AR: AR.695.002431.007864.024911
     * method:hook interface
     * Unisoc Code @{
     */
    YLogBuffer::getInstance()->log(logId, header->realtime, cred->pid, header->tid, msg,
                ((size_t)n <= UINT16_MAX) ? (uint16_t)n : UINT16_MAX) ;
    /** @} */
}

```
## Native hang 机制
### kernel下的实现
Native hang驱动代码：
```C
//vendor\bsp\kernel5.15\kernel5.15\drivers\unisoc_platform\sysdump\hang_monitor.c
//创建驱动设备/dev/native_hang_monitor，用于设置超时时间
static int native_hang_init(void)
{
	/*	create /dev/native_hang_monitor */
｝

static struct miscdevice native_hang_monitor_dev = {
	.minor = MISC_DYNAMIC_MINOR,
	.name = "native_hang_monitor",
	.fops = &native_hang_monitor_fops,
};

static const struct file_operations native_hang_monitor_fops = {
	.owner = THIS_MODULE,
	.unlocked_ioctl = monitor_hang_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl = monitor_hang_ioctl,
#endif
};

//创建2个内核线程
//超时触发panic
	hd_thread = kthread_run(hang_detect_thread, NULL, "native_hang_detect");
//超时保存kernel log和关键Android服务堆栈
	hdinfo_thread = kthread_run(hang_detect_thread_info, NULL, "native_hang_detect_info");

//hang_detect_thread 会检查是否超时，如果超时就通知hang_detect_thread_info去保存log，然后睡眠
40S让log能保存，再触发panic.

//注册minidump log区域，用于保存上层堆栈信息
ret = minidump_save_extend_information("nhang", __pa(hang_info), __pa(hang_info + HANG_INFO_MAX));
//注册minidump log区域，用于保存kernel log
ret = minidump_save_extend_information("nh_log_buf", __pa(nh_log_buf), __pa(nh_log_buf + NH_LOGBUF_SIZE));
```

### android 实现
```java
//watchdog 代码
//system/vendor/sprd/platform/frameworks/base/services/core/java/com/android/server/UnisocWatchdogImpl.java
//设置超时时间
 public void writeWDTMonitor(int duration){

            if(sWatchdogOptimization.mHugeTaskRunning){
                duration = (int)sWatchdogOptimization.HUGETASK_DEFAULT_DUATION ;
                Slog.e(TAG,"WDT_Monitorwpp: writeWDTMonitor reduration(hugeTask)=" + duration);
            } else if(sWatchdogOptimization.checkIfVeryLowPerformance()){
                duration += Math.max(30,mNextNativeHangAddedValue);
                Slog.e(TAG,"WDT_Monitorwpp: writeWDTMonitor reduration(lowperformance)=" + duration);
            } else if (mNextNativeHangAddedValue > 0) {
                duration += mNextNativeHangAddedValue;
                Slog.e(TAG,"WDT_Monitorwpp: writeWDTMonitor reduration(busy)=" + duration);
            }
            try {
                openNativeHangMonitorFile();
                if(fdNativeHangMonitorFile != null && !shutdowning){
                    Os.ioctlInt(fdNativeHangMonitorFile,NativeHangMonitor_SS_WDT_CTRL_SET_PARA|0x30|(duration*64));
                }
            } catch (Exception e){
                //if write NativeHangMonitorFile failed, kernel native hang monitor may be triggered
                Slog.e(TAG,"WDT_Monitor: Failed to write native hang Monitor :"+e);
            }
        }
        
//消息函数更新超时
    public void  doEmergencyMessage(int messageId) {
        if (messageId == UNISOCWATCHDOG_MESSAGE_TIMER30) {
            //normal feeding
            sWDTHandler.writeWDTMonitor(WDTHandler.NativeHangMonitor_Duration_Normal);
            if (isDebug()) {
                updateNHAddedValue();
            }
        }else if (messageId >= UNISOCWATCHDOG_MESSAGE_WAITEDHALF1 &&
                messageId <= UNISOCWATCHDOG_MESSAGE_OVERDUE) {
            //feeding a long time watchdog to avoid timeout during HALF/OVERDUE
            sWDTHandler.writeWDTMonitor(3*WDTHandler.NativeHangMonitor_Duration_Normal);
        }
    }
     public void sendMessage(int messageId, int timeout){
        f(blocking && (timeout != 0)){
                sWDTHandler.writeWDTMonitor(WDTHandler.NativeHangMonitor_Duration_Normal);
                if(timeout < 0)
                    timeout = WDTHandler.NativeHangMonitor_Duration_Normal/2;
            }
     ｝
     
//创建实例
    public static UnisocWatchdog getInstance(Context context,ActivityManagerService activity) {
        if (null == sUnisocWatchdog) {
            sUnisocWatchdog = new UnisocWatchdogImpl(context,activity);
        }
        return sUnisocWatchdog;
    }
```

Android中的watchdog实现
```
//system/frameworks/base/services/core/java/com/android/server/Watchdog.java

//创建sUnisocWatchdog
  public void init(Context context, ActivityManagerService activity) {
        mActivity = activity;
        context.registerReceiver(new RebootRequestReceiver(),
                new IntentFilter(Intent.ACTION_REBOOT),
                android.Manifest.permission.REBOOT, null);
        //Unisoc: initialize  UnisocWatchdog
        /** Unisoc: native hang watchdog
        * AR: AR.695.001080.003268.012033
        * method: modify directly
        * Unisoc Code @{
        */
        sUnisocWatchdog = UniSystemServiceFactory.getInstance().makeUnisocWatchdog(context,activity);
        /* @} */
    }
    
//在watchdog的run函数中，根据系统状态发送message 更新超时时间
 private void run() {
        boolean waitedHalf = false;

        while (true) {
            if(sUnisocWatchdog != null){
                sUnisocWatchdog.doEmergencyMessage(UnisocWatchdog.UNISOCWATCHDOG_MESSAGE_TIMER30);
                sUnisocWatchdog.sendMessage(UnisocWatchdog.UNISOCWATCHDOG_MESSAGE_TIMER30,0);
            }else
                Slog.e(TAG,"sUnisocWatchdog not initialized ");
            /* @} */
            //根据watchdog 的状态更新UnisocWatchdog
              final int waitState = evaluateCheckerCompletionLocked();
                if (waitState == COMPLETED) {
                    // The monitors have returned; reset
                    waitedHalf = false;
                    continue;
                } else if (waitState == WAITING) {
                    // still waiting but within their configured intervals; back off and recheck
                    /** Unisoc: native hang watchdog
                    * AR: AR.695.001080.003268.012033
                    * method: modify directly
                    * Unisoc Code @{
                    */
                    if (sUnisocWatchdog != null)//Unisoc:
                        sUnisocWatchdog.sendMessage(UnisocWatchdog.UNISOCWATCHDOG_MESSAGE_WAITING,0);
                    /* @} */
                    continue;
                } else if (waitState == WAITED_UNTIL_PRE_WATCHDOG) {
                    if (!waitedHalf) {
                        Slog.i(TAG, "WAITED_UNTIL_PRE_WATCHDOG");
                        /** Unisoc: native hang watchdog
                        * AR: AR.695.001080.003268.012033
                        * method: modify directly
                        * Unisoc Code @{
                        */
                        if (sUnisocWatchdog != null)
                            sUnisocWatchdog.sendMessage(UnisocWatchdog.UNISOCWATCHDOG_MESSAGE_WAITEDHALF1,10);
                        /* @} */
                        waitedHalf = true;
                        // We've waited until the pre-watchdog, but we'd need to do the stack trace
                        // dump w/o the lock.
                        blockedCheckers = getCheckersWithStateLocked(WAITED_UNTIL_PRE_WATCHDOG);
                        subject = describeCheckersLocked(blockedCheckers);
                        pids = new ArrayList<>(mInterestingJavaPids);
                        doWaitedPreDump = true;
                    } else {
                        /** Unisoc: native hang watchdog
                        * AR: AR.695.001080.003268.012033
                        * method: modify directly
                        * Unisoc Code @{
                        */
                        if (sUnisocWatchdog != null)
                            sUnisocWatchdog.sendMessage(UnisocWatchdog.UNISOCWATCHDOG_MESSAGE_WAITEDHALF2,10);
                        /* @} */
                        continue;
                    }
                } else {
                    // something is overdue!
                    blockedCheckers = getCheckersWithStateLocked(OVERDUE);
                    subject = describeCheckersLocked(blockedCheckers);
                    allowRestart = mAllowRestart;
                    pids = new ArrayList<>(mInterestingJavaPids);
                }
```

## magic键触发panic(同时按住Vu Vd,再双击pwr key)


## watchdog 实现
### lk的实现
代码：`vendor/bsp/bootloader/lk/platform/sprd_shared/driver/watchdog/sprd_wdt.c`

### kernel的实现


## 导出coredump
## 使用gdb 分析coredump
